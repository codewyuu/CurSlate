"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6713],{21605:e=>{e.exports=e=>{const t={};for(const[r,o]of Object.entries(e))t[r.toLowerCase()]=o;return t}},30096:(e,t,r)=>{const o=r(37007),c=r(88835),s=r(15972),a=r(4594),n=r(37234),i=r(79204),h=r(21605),l=r(89219),u=r(90971);class m{constructor(e,t){if("function"!=typeof e)throw new TypeError("Parameter `request` must be a function");return this.cache=new u({uri:"string"==typeof t&&t,store:"string"!=typeof t&&t,namespace:"cacheable-request"}),this.createCacheableRequest(e)}createCacheableRequest(e){return(t,r)=>{let u;if("string"==typeof t)u=p(c.parse(t)),t={};else if(t instanceof c.URL)u=p(c.parse(t.toString())),t={};else{const[e,...r]=(t.path||"").split("?"),o=r.length>0?`?${r.join("?")}`:"";u=p({...t,pathname:e,search:o})}(t={headers:{},method:"GET",cache:!0,strictTtl:!1,automaticFailover:!1,...t,...f(u)}).headers=h(t.headers);const d=new o,y=s(c.format(u),{stripWWW:!1,removeTrailingSlash:!1,stripAuthentication:!1}),w=`${t.method}:${y}`;let C=!1,b=!1;const P=t=>{b=!0;let o,c=!1;const s=new Promise((e=>{o=()=>{c||(c=!0,e())}})),h=e=>{if(C&&!t.forceRefresh){e.status=e.statusCode;const r=n.fromObject(C.cachePolicy).revalidatedPolicy(t,e);if(!r.modified){const t=r.policy.responseHeaders();(e=new i(C.statusCode,t,C.body,C.url)).cachePolicy=r.policy,e.fromCache=!0}}let o;e.fromCache||(e.cachePolicy=new n(t,e,t),e.fromCache=!1),t.cache&&e.cachePolicy.storable()?(o=l(e),(async()=>{try{const r=a.buffer(e);if(await Promise.race([s,new Promise((t=>e.once("end",t)))]),c)return;const o=await r,n={cachePolicy:e.cachePolicy.toObject(),url:e.url,statusCode:e.fromCache?C.statusCode:e.statusCode,body:o};let i=t.strictTtl?e.cachePolicy.timeToLive():void 0;t.maxTtl&&(i=i?Math.min(i,t.maxTtl):t.maxTtl),await this.cache.set(w,n,i)}catch(e){d.emit("error",new m.CacheError(e))}})()):t.cache&&C&&(async()=>{try{await this.cache.delete(w)}catch(e){d.emit("error",new m.CacheError(e))}})(),d.emit("response",o||e),"function"==typeof r&&r(o||e)};try{const r=e(t,h);r.once("error",o),r.once("abort",o),d.emit("request",r)}catch(e){d.emit("error",new m.RequestError(e))}};return(async()=>{const e=async e=>{await Promise.resolve();const t=e.cache?await this.cache.get(w):void 0;if(void 0===t)return P(e);const o=n.fromObject(t.cachePolicy);if(o.satisfiesWithoutRevalidation(e)&&!e.forceRefresh){const e=o.responseHeaders(),c=new i(t.statusCode,e,t.body,t.url);c.cachePolicy=o,c.fromCache=!0,d.emit("response",c),"function"==typeof r&&r(c)}else C=t,e.headers=o.revalidationHeaders(e),P(e)},o=e=>d.emit("error",new m.CacheError(e));this.cache.once("error",o),d.on("response",(()=>this.cache.removeListener("error",o)));try{await e(t)}catch(e){t.automaticFailover&&!b&&P(t),d.emit("error",new m.CacheError(e))}})(),d}}}function f(e){const t={...e};return t.path=`${e.pathname||"/"}${e.search||""}`,delete t.pathname,delete t.search,t}function p(e){return{protocol:e.protocol,auth:e.auth,hostname:e.hostname||e.host||"localhost",port:e.port,pathname:e.pathname,search:e.search}}m.RequestError=class extends Error{constructor(e){super(e.message),this.name="RequestError",Object.assign(this,e)}},m.CacheError=class extends Error{constructor(e){super(e.message),this.name="CacheError",Object.assign(this,e)}},e.exports=m}}]);