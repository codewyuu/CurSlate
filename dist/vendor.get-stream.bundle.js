"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3972],{4594:(e,r,t)=>{const{constants:n}=t(48287),f=t(20815),s=t(55635);class a extends Error{constructor(){super("maxBuffer exceeded"),this.name="MaxBufferError"}}async function o(e,r){if(!e)return Promise.reject(new Error("Expected a stream"));r={maxBuffer:1/0,...r};const{maxBuffer:t}=r;let o;return await new Promise(((u,c)=>{const d=e=>{e&&o.getBufferedLength()<=n.MAX_LENGTH&&(e.bufferedData=o.getBufferedValue()),c(e)};o=f(e,s(r),(e=>{e?d(e):u()})),o.on("data",(()=>{o.getBufferedLength()>t&&d(new a)}))})),o.getBufferedValue()}e.exports=o,e.exports.default=o,e.exports.buffer=(e,r)=>o(e,{...r,encoding:"buffer"}),e.exports.array=(e,r)=>o(e,{...r,array:!0}),e.exports.MaxBufferError=a},55635:(e,r,t)=>{var n=t(48287).Buffer;const{PassThrough:f}=t(88310);e.exports=e=>{e={...e};const{array:r}=e;let{encoding:t}=e;const s="buffer"===t;let a=!1;r?a=!(t||s):t=t||"utf8",s&&(t=null);const o=new f({objectMode:a});t&&o.setEncoding(t);let u=0;const c=[];return o.on("data",(e=>{c.push(e),a?u=c.length:u+=e.length})),o.getBufferedValue=()=>r?c:s?n.concat(c,u):c.join(""),o.getBufferedLength=()=>u,o}}}]);