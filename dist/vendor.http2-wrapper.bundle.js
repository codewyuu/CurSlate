"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7299],{5769:(e,t,s)=>{const o=s(10135),r=s(17444),n=s(22734),i=s(87235),h=s(22094);e.exports={...o,ClientRequest:n,IncomingMessage:i,...r,request:(e,t,s)=>new n(e,t,s),get:(e,t,s)=>{const o=new n(e,t,s);return o.end(),o},auto:h}},17444:(e,t,s)=>{const o=s(37007),r=s(42867),n=s(10135),i=s(87392),h=Symbol("currentStreamsCount"),a=Symbol("request"),c=Symbol("cachedOriginSet"),u=Symbol("gracefullyClosing"),l=["maxDeflateDynamicTableSize","maxSessionMemory","maxHeaderListPairs","maxOutstandingPings","maxReservedRemoteStreams","maxSendHeaderBlockLength","paddingStrategy","localAddress","path","rejectUnauthorized","minDHSize","ca","cert","clientCertEngine","ciphers","key","pfx","servername","minVersion","maxVersion","secureProtocol","crl","honorCipherOrder","ecdhCurve","dhparam","secureOptions","sessionIdContext"],d=(e,t)=>e.remoteSettings.maxConcurrentStreams>t.remoteSettings.maxConcurrentStreams,m=(e,t)=>{for(const s of e)s[c].length<t[c].length&&s[c].every((e=>t[c].includes(e)))&&s[h]+t[h]<=t.remoteSettings.maxConcurrentStreams&&p(s)},f=({agent:e,isFree:t})=>{const s={};for(const o in e.sessions){const r=e.sessions[o].filter((e=>{const s=e[g.kCurrentStreamsCount]<e.remoteSettings.maxConcurrentStreams;return t?s:!s}));0!==r.length&&(s[o]=r)}return s},p=e=>{e[u]=!0,0===e[h]&&e.close()};class g extends o{constructor({timeout:e=6e4,maxSessions:t=1/0,maxFreeSessions:s=10,maxCachedTlsSessions:o=100}={}){super(),this.sessions={},this.queue={},this.timeout=e,this.maxSessions=t,this.maxFreeSessions=s,this._freeSessionsCount=0,this._sessionsCount=0,this.settings={enablePush:!1},this.tlsSessionCache=new i({maxSize:o})}static normalizeOrigin(e,t){return"string"==typeof e&&(e=new URL(e)),t&&e.hostname!==t&&(e.hostname=t),e.origin}normalizeOptions(e){let t="";if(e)for(const s of l)e[s]&&(t+=`:${e[s]}`);return t}_tryToCreateNewSession(e,t){if(!(e in this.queue)||!(t in this.queue[e]))return;const s=this.queue[e][t];this._sessionsCount<this.maxSessions&&!s.completed&&(s.completed=!0,s())}getSession(e,t,s){return new Promise(((o,r)=>{Array.isArray(s)?(s=[...s],o()):s=[{resolve:o,reject:r}];const i=this.normalizeOptions(t),l=g.normalizeOrigin(e,t&&t.servername);if(void 0===l){for(const{reject:e}of s)e(new TypeError("The `origin` argument needs to be a string or an URL object"));return}if(i in this.sessions){const e=this.sessions[i];let t,o=-1,r=-1;for(const s of e){const e=s.remoteSettings.maxConcurrentStreams;if(e<o)break;if(s[c].includes(l)){const n=s[h];if(n>=e||s[u]||s.destroyed)continue;t||(o=e),n>r&&(t=s,r=n)}}if(t){if(1!==s.length){for(const{reject:e}of s)e(new Error(`Expected the length of listeners to be 1, got ${s.length}.\nPlease report this to https://github.com/szmarczak/http2-wrapper/`));return}return void s[0].resolve(t)}}if(i in this.queue){if(l in this.queue[i])return this.queue[i][l].listeners.push(...s),void this._tryToCreateNewSession(i,l)}else this.queue[i]={};const f=()=>{i in this.queue&&this.queue[i][l]===y&&(delete this.queue[i][l],0===Object.keys(this.queue[i]).length&&delete this.queue[i])},y=()=>{const o=`${l}:${i}`;let r=!1;try{const g=n.connect(e,{createConnection:this.createConnection,settings:this.settings,session:this.tlsSessionCache.get(o),...t});g[h]=0,g[u]=!1;const S=()=>g[h]<g.remoteSettings.maxConcurrentStreams;let _=!0;g.socket.once("session",(e=>{this.tlsSessionCache.set(o,e)})),g.once("error",(e=>{for(const{reject:t}of s)t(e);this.tlsSessionCache.delete(o)})),g.setTimeout(this.timeout,(()=>{g.destroy()})),g.once("close",(()=>{if(r){_&&this._freeSessionsCount--,this._sessionsCount--;const e=this.sessions[i];e.splice(e.indexOf(g),1),0===e.length&&delete this.sessions[i]}else{const e=new Error("Session closed without receiving a SETTINGS frame");e.code="HTTP2WRAPPER_NOSETTINGS";for(const{reject:t}of s)t(e);f()}this._tryToCreateNewSession(i,l)}));const T=()=>{if(i in this.queue&&S())for(const e of g[c])if(e in this.queue[i]){const{listeners:t}=this.queue[i][e];for(;0!==t.length&&S();)t.shift().resolve(g);const s=this.queue[i];if(0===s[e].listeners.length&&(delete s[e],0===Object.keys(s).length)){delete this.queue[i];break}if(!S())break}};g.on("origin",(()=>{g[c]=g.originSet,S()&&(T(),m(this.sessions[i],g))})),g.once("remoteSettings",(()=>{if(g.ref(),g.unref(),this._sessionsCount++,y.destroyed){const e=new Error("Agent has been destroyed");for(const t of s)t.reject(e);g.destroy()}else{g[c]=g.originSet;{const e=this.sessions;if(i in e){const t=e[i];t.splice(((e,t,s)=>{let o=0,r=e.length;for(;o<r;){const n=o+r>>>1;s(e[n],t)?o=n+1:r=n}return o})(t,g,d),0,g)}else e[i]=[g]}this._freeSessionsCount+=1,r=!0,this.emit("session",g),T(),f(),0===g[h]&&this._freeSessionsCount>this.maxFreeSessions&&g.close(),0!==s.length&&(this.getSession(l,t,s),s.length=0),g.on("remoteSettings",(()=>{T(),m(this.sessions[i],g)}))}})),g[a]=g.request,g.request=(e,t)=>{if(g[u])throw new Error("The session is gracefully closing. No new streams are allowed.");const s=g[a](e,t);return g.ref(),++g[h],g[h]===g.remoteSettings.maxConcurrentStreams&&this._freeSessionsCount--,s.once("close",(()=>{if(_=S(),--g[h],!g.destroyed&&!g.closed&&(((e,t)=>{for(const s of e)t[c].length<s[c].length&&t[c].every((e=>s[c].includes(e)))&&t[h]+s[h]<=s.remoteSettings.maxConcurrentStreams&&p(t)})(this.sessions[i],g),S()&&!g.closed)){_||(this._freeSessionsCount++,_=!0);const e=0===g[h];e&&g.unref(),e&&(this._freeSessionsCount>this.maxFreeSessions||g[u])?g.close():(m(this.sessions[i],g),T())}})),s}}catch(e){for(const t of s)t.reject(e);f()}};y.listeners=s,y.completed=!1,y.destroyed=!1,this.queue[i][l]=y,this._tryToCreateNewSession(i,l)}))}request(e,t,s,o){return new Promise(((r,n)=>{this.getSession(e,t,[{reject:n,resolve:e=>{try{r(e.request(s,o))}catch(e){n(e)}}}])}))}createConnection(e,t){return g.connect(e,t)}static connect(e,t){t.ALPNProtocols=["h2"];const s=e.port||443,o=e.hostname||e.host;return void 0===t.servername&&(t.servername=o),r.connect(s,o,t)}closeFreeSessions(){for(const e of Object.values(this.sessions))for(const t of e)0===t[h]&&t.close()}destroy(e){for(const t of Object.values(this.sessions))for(const s of t)s.destroy(e);for(const e of Object.values(this.queue))for(const t of Object.values(e))t.destroyed=!0;this.queue={}}get freeSessions(){return f({agent:this,isFree:!0})}get busySessions(){return f({agent:this,isFree:!1})}}g.kCurrentStreamsCount=h,g.kGracefullyClosing=u,e.exports={Agent:g,globalAgent:new g}},21125:e=>{e.exports=(e,t,s)=>{for(const o of s)e.on(o,((...e)=>t.emit(o,...e)))}},22094:(e,t,s)=>{const o=s(11568),r=s(11083),n=s(51169),i=s(87392),h=s(22734),a=s(50491),c=s(99025),u=new i({maxSize:100}),l=new Map,d=(e,t,s)=>{t._httpMessage={shouldKeepAlive:!0};const o=()=>{e.emit("free",t,s)};t.on("free",o);const r=()=>{e.removeSocket(t,s)};t.on("close",r);const n=()=>{e.removeSocket(t,s),t.off("close",r),t.off("free",o),t.off("agentRemove",n)};t.on("agentRemove",n),e.emit("free",t,s)};e.exports=async(e,t,s)=>{if(("string"==typeof e||e instanceof URL)&&(e=c(new URL(e))),"function"==typeof t&&(s=t,t=void 0),t={ALPNProtocols:["h2","http/1.1"],...e,...t,resolveSocket:!0},!Array.isArray(t.ALPNProtocols)||0===t.ALPNProtocols.length)throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");t.protocol=t.protocol||"https:";const i="https:"===t.protocol;t.host=t.hostname||t.host||"localhost",t.session=t.tlsSession,t.servername=t.servername||a(t),t.port=t.port||(i?443:80),t._defaultAgent=i?r.globalAgent:o.globalAgent;const m=t.agent;if(m){if(m.addRequest)throw new Error("The `options.agent` object can contain only `http`, `https` or `http2` properties");t.agent=m[i?"https":"http"]}if(i){const e=await(async e=>{const t=`${e.host}:${e.port}:${e.ALPNProtocols.sort()}`;if(!u.has(t)){if(l.has(t))return(await l.get(t)).alpnProtocol;const{path:s,agent:o}=e;e.path=e.socketPath;const i=n(e);l.set(t,i);try{const{socket:n,alpnProtocol:h}=await i;if(u.set(t,h),e.path=s,"h2"===h)n.destroy();else{const{globalAgent:t}=r,s=r.Agent.prototype.createConnection;o?o.createConnection===s?d(o,n,e):n.destroy():t.createConnection===s?d(t,n,e):n.destroy()}return l.delete(t),h}catch(e){throw l.delete(t),e}}return u.get(t)})(t);if("h2"===e)return m&&(t.agent=m.http2),new h(t,s)}return o.request(t,s)},e.exports.protocolCache=u},22734:(e,t,s)=>{var o=s(48287).Buffer,r=s(65606);const n=s(10135),{Writable:i}=s(88310),{Agent:h,globalAgent:a}=s(17444),c=s(87235),u=s(99025),l=s(21125),d=s(33610),{ERR_INVALID_ARG_TYPE:m,ERR_INVALID_PROTOCOL:f,ERR_HTTP_HEADERS_SENT:p,ERR_INVALID_HTTP_TOKEN:g,ERR_HTTP_INVALID_HEADER_VALUE:y,ERR_INVALID_CHAR:S}=s(73876),{HTTP2_HEADER_STATUS:_,HTTP2_HEADER_METHOD:T,HTTP2_HEADER_PATH:w,HTTP2_METHOD_CONNECT:E}=n.constants,C=Symbol("headers"),A=Symbol("origin"),b=Symbol("session"),R=Symbol("options"),q=Symbol("flushedHeaders"),x=Symbol("jobs"),v=/^[\^`\-\w!#$%&*+.|~]+$/,H=/[^\t\u0020-\u007E\u0080-\u00FF]/;e.exports=class extends i{constructor(e,t,s){super({autoDestroy:!1});const r="string"==typeof e||e instanceof URL;if(r&&(e=u(e instanceof URL?e:new URL(e))),"function"==typeof t||void 0===t?(s=t,t=r?e:{...e}):t={...e,...t},t.h2session)this[b]=t.h2session;else if(!1===t.agent)this.agent=new h({maxFreeSessions:0});else if(void 0===t.agent||null===t.agent)"function"==typeof t.createConnection?(this.agent=new h({maxFreeSessions:0}),this.agent.createConnection=t.createConnection):this.agent=a;else{if("function"!=typeof t.agent.request)throw new m("options.agent",["Agent-like Object","undefined","false"],t.agent);this.agent=t.agent}if(t.protocol&&"https:"!==t.protocol)throw new f(t.protocol,"https:");const n=t.port||t.defaultPort||this.agent&&this.agent.defaultPort||443,i=t.hostname||t.host||"localhost";delete t.hostname,delete t.host,delete t.port;const{timeout:c}=t;if(t.timeout=void 0,this[C]=Object.create(null),this[x]=[],this.socket=null,this.connection=null,this.method=t.method||"GET",this.path=t.path,this.res=null,this.aborted=!1,this.reusedSocket=!1,t.headers)for(const[e,s]of Object.entries(t.headers))this.setHeader(e,s);t.auth&&!("authorization"in this[C])&&(this[C].authorization="Basic "+o.from(t.auth).toString("base64")),t.session=t.tlsSession,t.path=t.socketPath,this[R]=t,443===n?(this[A]=`https://${i}`,":authority"in this[C]||(this[C][":authority"]=i)):(this[A]=`https://${i}:${n}`,":authority"in this[C]||(this[C][":authority"]=`${i}:${n}`)),c&&this.setTimeout(c),s&&this.once("response",s),this[q]=!1}get method(){return this[C][T]}set method(e){e&&(this[C][T]=e.toUpperCase())}get path(){return this[C][w]}set path(e){e&&(this[C][w]=e)}get _mustNotHaveABody(){return"GET"===this.method||"HEAD"===this.method||"DELETE"===this.method}_write(e,t,s){if(this._mustNotHaveABody)return void s(new Error("The GET, HEAD and DELETE methods must NOT have a body"));this.flushHeaders();const o=()=>this._request.write(e,t,s);this._request?o():this[x].push(o)}_final(e){if(this.destroyed)return;this.flushHeaders();const t=()=>{this._mustNotHaveABody?e():this._request.end(e)};this._request?t():this[x].push(t)}abort(){this.res&&this.res.complete||(this.aborted||r.nextTick((()=>this.emit("abort"))),this.aborted=!0,this.destroy())}_destroy(e,t){this.res&&this.res._dump(),this._request&&this._request.destroy(),t(e)}async flushHeaders(){if(this[q]||this.destroyed)return;this[q]=!0;const e=this.method===E,t=t=>{if(this._request=t,this.destroyed)return void t.destroy();e||l(t,this,["timeout","continue","close","error"]);const s=e=>(...t)=>{this.writable||this.destroyed?this.once("finish",(()=>{e(...t)})):e(...t)};t.once("response",s(((s,r,n)=>{const i=new c(this.socket,t.readableHighWaterMark);this.res=i,i.req=this,i.statusCode=s[_],i.headers=s,i.rawHeaders=n,i.once("end",(()=>{this.aborted?(i.aborted=!0,i.emit("aborted")):(i.complete=!0,i.socket=null,i.connection=null)})),e?(i.upgrade=!0,this.emit("connect",i,t,o.alloc(0))?this.emit("close"):t.destroy()):(t.on("data",(e=>{i._dumped||i.push(e)||t.pause()})),t.once("end",(()=>{i.push(null)})),this.emit("response",i)||i._dump())}))),t.once("headers",s((e=>this.emit("information",{statusCode:e[_]})))),t.once("trailers",s(((e,t,s)=>{const{res:o}=this;o.trailers=e,o.rawTrailers=s})));const{socket:r}=t.session;this.socket=r,this.connection=r;for(const e of this[x])e();this.emit("socket",this.socket)};if(this[b])try{t(this[b].request(this[C]))}catch(e){this.emit("error",e)}else{this.reusedSocket=!0;try{t(await this.agent.request(this[A],this[R],this[C]))}catch(e){this.emit("error",e)}}}getHeader(e){if("string"!=typeof e)throw new m("name","string",e);return this[C][e.toLowerCase()]}get headersSent(){return this[q]}removeHeader(e){if("string"!=typeof e)throw new m("name","string",e);if(this.headersSent)throw new p("remove");delete this[C][e.toLowerCase()]}setHeader(e,t){if(this.headersSent)throw new p("set");if("string"!=typeof e||!v.test(e)&&!d(e))throw new g("Header name",e);if(void 0===t)throw new y(t,e);if(H.test(t))throw new S("header content",e);this[C][e.toLowerCase()]=t}setNoDelay(){}setSocketKeepAlive(){}setTimeout(e,t){const s=()=>this._request.setTimeout(e,t);return this._request?s():this[x].push(s),this}get maxHeadersCount(){if(!this.destroyed&&this._request)return this._request.session.localSettings.maxHeaderListSize}set maxHeadersCount(e){}}},33610:e=>{e.exports=e=>{switch(e){case":method":case":scheme":case":authority":case":path":return!0;default:return!1}}},50491:(e,t,s)=>{const o=s(46165);e.exports=e=>{let t=e.host;const s=e.headers&&e.headers.host;return s&&(t=s.startsWith("[")?-1===s.indexOf("]")?s:s.slice(1,-1):s.split(":",1)[0]),o.isIP(t)?"":t}},73876:e=>{const t=(t,s,o)=>{e.exports[s]=class extends t{constructor(...e){super("string"==typeof o?o:o(e)),this.name=`${super.name} [${s}]`,this.code=s}}};t(TypeError,"ERR_INVALID_ARG_TYPE",(e=>{const t=e[0].includes(".")?"property":"argument";let s=e[1];const o=Array.isArray(s);return o&&(s=`${s.slice(0,-1).join(", ")} or ${s.slice(-1)}`),`The "${e[0]}" ${t} must be ${o?"one of":"of"} type ${s}. Received ${typeof e[2]}`})),t(TypeError,"ERR_INVALID_PROTOCOL",(e=>`Protocol "${e[0]}" not supported. Expected "${e[1]}"`)),t(Error,"ERR_HTTP_HEADERS_SENT",(e=>`Cannot ${e[0]} headers after they are sent to the client`)),t(TypeError,"ERR_INVALID_HTTP_TOKEN",(e=>`${e[0]} must be a valid HTTP token [${e[1]}]`)),t(TypeError,"ERR_HTTP_INVALID_HEADER_VALUE",(e=>`Invalid value "${e[0]} for header "${e[1]}"`)),t(TypeError,"ERR_INVALID_CHAR",(e=>`Invalid character in ${e[0]} [${e[1]}]`))},87235:(e,t,s)=>{const{Readable:o}=s(88310);e.exports=class extends o{constructor(e,t){super({highWaterMark:t,autoDestroy:!1}),this.statusCode=null,this.statusMessage="",this.httpVersion="2.0",this.httpVersionMajor=2,this.httpVersionMinor=0,this.headers={},this.trailers={},this.req=null,this.aborted=!1,this.complete=!1,this.upgrade=null,this.rawHeaders=[],this.rawTrailers=[],this.socket=e,this.connection=e,this._dumped=!1}_destroy(e){this.req._request.destroy(e)}setTimeout(e,t){return this.req.setTimeout(e,t),this}_dump(){this._dumped||(this._dumped=!0,this.removeAllListeners("data"),this.resume())}_read(){this.req&&this.req._request.resume()}}},99025:e=>{e.exports=e=>{const t={protocol:e.protocol,hostname:"string"==typeof e.hostname&&e.hostname.startsWith("[")?e.hostname.slice(1,-1):e.hostname,host:e.host,hash:e.hash,search:e.search,pathname:e.pathname,href:e.href,path:`${e.pathname||""}${e.search||""}`};return"string"==typeof e.port&&0!==e.port.length&&(t.port=Number(e.port)),(e.username||e.password)&&(t.auth=`${e.username||""}:${e.password||""}`),t}}}]);